
# Reference:
- [CS:APP Cache Lab 解題筆記](https://hackmd.io/@Chang-Chia-Chi/rkRCq_vbY)
- https://github.com/Zhenye-Na/CSAPP-Labs/blob/master/labs/Lab6-Cache%20Lab/cachelab/csim.c
- https://github.com/Guo749/CSAPP/blob/master/02_lab/lab3_cachelab/cachelab-handout/csim.c#L27


# Commands: 
make csim
./csim -v -s 4 -E 1 -b 4 -t traces/yi.trace
/test-csim




## 4.1 Reference Trace Files
The traces subdirectory of the handout directory contains a collection of reference trace files that we will use to evaluate the correctness of the cache simulator you write in Part A. 
The trace files are generated by a Linux program called `valgrind`. For example, typing 
```bash
linux> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l
```
on the command line runs the executable program “ls -l”, captures a trace of each of its memory accesses in the order they occur, and prints them on stdout.

Valgrind memory traces have the following form:
I 0400d7d4,8
 M 0421c7f0,4
 L 04f6b868,8
 S 7ff0005c8,8

Each line denotes one or two memory accesses. The format of each line is
`[space]operation address,size`

The operation field denotes the type of memory access:

-  “I” denotes an instruction load,
-  “L” a data load,
-  “S” a data store,
-  “M” a data modify (i.e., a data load followed by a data store).

There is never a space before each “I”.
There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit
hexadecimal memory address. 
The size field specifies the number of bytes accessed by the operation.


In Valgrind traces, these operations help track how a program interacts with memory, providing insights for debugging and performance analysis.

- Data Load (L): A data load refers to the operation where the CPU reads data from memory.
- Data Store (S) : A data store refers to the operation where the CPU writes data to memory.
- Data Modify (M): A data modify operation is a combination of a data load followed by a data store to the same memory address.
This can happen during operations like incrementing a variable (x++), or performing a read-modify-write cycle in arithmetic or logical operations.


## 4.2 Part A: Cache Simulator

In Part A you will write a cache simulator in csim.c that takes a valgrind memory trace as input,
simulates the hit/miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions.

### The reference simulator
We have provided you with the binary executable of a reference cache simulator, called `csim-ref`, that simulates the behavior of a cache with arbitrary size and associativity on a valgrind trace file. It uses the LRU (least-recently used) replacement policy when choosing which cache line to evict.
The reference simulator takes the following command-line arguments:

```bash
Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>
- -h: Optional help flag that prints usage info
- -v: Optional verbose flag that displays trace info
- -s <s>: Number of set index bits (S = 2s is the number of sets)
- -E <E>: Associativity (number of lines per set)
- -b <b>: Number of block bits (B = 2b is the block size)
- -t <tracefile>: Name of the valgrind trace to replay
```

### Example:
```bash
linux> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace
hits:4 misses:5 evictions:3

# The same example in verbose mode:
linux> ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace
L 10,1 miss
M 20,1 miss hit
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3
```

Your job for Part A is to fill in the csim.c file so that it takes the same command line arguments and produces the identical output as the reference simulator. Notice that this file is almost completely empty. You’ll need to write it from scratch.


## Programming Rules for Part A
- Include your name and loginID in the header comment for csim.c.
- Your csim.c file must compile without warnings in order to receive credit.
- Your simulator must work correctly for arbitrary s, E, and b. 
  This means that you will need to allocate storage for your simulator’s data structures using the `malloc` function. 
  Type “man malloc” for information about this function.
- For this lab, we are interested only in data cache performance, so your simulator should ignore all instruction cache accesses (lines starting with “I”). 
  Recall that valgrind always puts “I” in the first column (with no preceding space), and “M”, “L”, and “S” in the second column (with a preceding
space). This may help you parse the trace.
- To receive credit for Part A, you must call the function `printSummary`, with the total number of
hits, misses, and evictions, at the end of your main function:
`printSummary(hit_count, miss_count, eviction_count);`
- For this this lab, you should assume that memory accesses are aligned properly, such that a single memory access never crosses block boundaries. By making this assumption, you can ignore the
request sizes in the valgrind traces.


# Part B write a matrix transpose function that is optimized for cache performance.

In Part B you will write a transpose function in trans.c that causes as few cache misses as possible.
Let A denote a matrix, and Aij denote the component on the ith row and jth column. The transpose of A,
denoted AT , is a matrix such that Aij = ATj
i.
To help you get started, we have given you an example transpose function in trans.c that computes the
transpose of N ×M matrix A and stores the results in M × N matrix B:
char trans_desc[] = "Simple row-wise scan transpose";
void trans(int M, int N, int A[N][M], int B[M][N])
The example transpose function is correct, but it is inefficient because the access pattern results in relatively
many cache misses.
Your job in Part B is to write a similar function, called transpose_submit, that minimizes the number
of cache misses across different sized matrices:
char transpose_submit_desc[] = "Transpose submission";
void transpose_submit(int M, int N, int A[N][M], int B[M][N]);
Do not change the description string (“Transpose submission”) for your transpose_submit
function. The autograder searches for this string to determine which transpose function to evaluate for
credit.
4
Programming Rules for Part B
- Include your name and loginID in the header comment for trans.c.
- Your code in trans.c must compile without warnings to receive credit.
- You are allowed to define at most 12 local variables of type int per transpose function.1
- You are not allowed to side-step the previous rule by using any variables of type long or by using
any bit tricks to store more than one value to a single variable.
- Your transpose function may not use recursion.
- If you choose to use helper functions, you may not have more than 12 local variables on the stack
at a time between your helper functions and your top level transpose function. For example, if your
transpose declares 8 variables, and then you call a function which uses 4 variables, which calls another
function which uses 2, you will have 14 variables on the stack, and you will be in violation of the rule.
- Your transpose function may not modify array A. You may, however, do whatever you want with the
contents of array B.
- You are NOT allowed to define any arrays in your code or to use any variant of malloc.


# 5 Evaluation

This section describes how your work will be evaluated. The full score for this lab is 60 points:
- Part A: 27 Points
- Part B: 26 Points
- Style: 7 Points

## 5.1 Evaluation for Part A
For Part A, we will run your cache simulator using different cache parameters and traces. There are eight
test cases, each worth 3 points, except for the last case, which is worth 6 points:

```bash
linux> ./csim -s 1 -E 1 -b 1 -t traces/yi2.trace
linux> ./csim -s 4 -E 2 -b 4 -t traces/yi.trace
linux> ./csim -s 2 -E 1 -b 4 -t traces/dave.trace
linux> ./csim -s 2 -E 1 -b 3 -t traces/trans.trace
linux> ./csim -s 2 -E 2 -b 3 -t traces/trans.trace
linux> ./csim -s 2 -E 4 -b 3 -t traces/trans.trace
linux> ./csim -s 5 -E 1 -b 5 -t traces/trans.trace
linux> ./csim -s 5 -E 1 -b 5 -t traces/long.trace
```

You can use the reference simulator csim-ref to obtain the correct answer for each of these test cases.
During debugging, use the -v option for a detailed record of each hit and miss.
For each test case, outputting the correct number of cache hits, misses and evictions will give you full credit
for that test case. Each of your reported number of hits, misses and evictions is worth 1/3 of the credit
for that test case. That is, if a particular test case is worth 3 points, and your simulator outputs the correct
number of hits and misses, but reports the wrong number of evictions, then you will earn 2 points.


# 6 Working on the Lab

## 6.1 Working on Part A
We have provided you with an autograding program, called test-csim, that tests the correctness of your cache simulator on the reference traces. Be sure to compile your simulator before running the test:
```bash
linux> make
linux> ./test-csim

                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace 
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace  
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     0 (2,2,3)     175      63      55     201      37      29  traces/trans.trace
     0 (2,4,3)     205      33      17     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace 
    21
```


For each test, it shows the number of points you earned, the cache parameters, the input trace file, and a comparison of the results from your simulator and the reference simulator.

Here are some hints and suggestions for working on Part A:
- Do your initial debugging on the small traces, such as traces/dave.trace.
- The reference simulator takes an optional -v argument that enables verbose output, displaying the hits, misses, and evictions that occur as a result of each memory access. You are not required to implement this feature in your csim.c code, but we strongly recommend that you do so. It will help you debug by allowing you to directly compare the behavior of your simulator with the reference simulator on the reference trace files.
- We recommend that you use the `getopt` function to parse your command line arguments. You’ll need the following header files:

#include <getopt.h>
#include <stdlib.h>
#include <unistd.h>

See “man 3 getopt” for details.

- Each data load (L) or store (S) operation can cause at most one cache miss. The data modify operation (M) is treated as a load followed by a store to the same address. Thus, an M operation can result in two cache hits, or a miss and a hit plus a possible eviction.
- If you would like to use C0-style contracts from 15-122, you can include contracts.h, which we
have provided in the handout directory for your convenience.


## 6.3 Putting it all Together
We have provided you with a driver program, called ./driver.py, that performs a complete evaluation
of your simulator and transpose code. This is the same program your instructor uses to evaluate your
handins. The driver uses test-csim to evaluate your simulator, and it uses test-trans to evaluate
your submitted transpose function on the three matrix sizes. Then it prints a summary of your results and
the points you have earned.
To run the driver, type:
linux> ./driver.py