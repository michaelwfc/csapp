/**
 * make csim
 * ./csim -s 4 -E 1 -b 4 -t traces/yi.trace
 */
#include <stdio.h>
#include <getopt.h>
#include <stdlib.h>
#include <unistd.h> // For getopt 
#include <stdint.h>  // For uint64_t
#include <string.h>  // for memcpy
#include "cachelab.h"

#define MEMORY_SIZE 64

/* Always use a 64-bit variable to hold memory addresses*/
// typedef unsigned long long int MemAddrSize;
// typedef uint64_t MemAddrSize;
typedef long long unsigned int MemAddrSize; //%llx

/* Cache parameters struct */
typedef struct CacheParams{
    unsigned s; // s bits for set address
    unsigned E; // E line for each set
    unsigned b; // b blocks for each line
    // uint64_t S; // S =2^s sets
    // uint64_t B; // B = 2^b blocks per line
    char *trace_file;     /* valgrind trace file */
} CacheParams;


/*
In Part A you will write a cache simulator in csim.c that takes a valgrind memory trace as input,
simulates the hit/miss behavior of a cache memory on this trace, and outputs the total number of hits,
misses, and evictions.

We have provided you with the binary executable of a reference cache simulator, called csim-ref, that
simulates the behavior of a cache with arbitrary size and associativity on a valgrind trace file. It uses the
LRU (least-recently used) replacement policy when choosing which cache line to evict.
The reference simulator takes the following command-line arguments:

Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>
• -h: Optional help flag that prints usage info
• -v: Optional verbose flag that displays trace info
• -s <s>: Number of set index bits (S = 2s is the number of sets)
• -E <E>: Associativity (number of lines per set)
• -b <b>: Number of block bits (B = 2b is the block size)
• -t <tracefile>: Name of the valgrind trace to replay


4.1 Reference Trace Files
The traces subdirectory of the handout directory contains a collection of reference trace files that we will
use to evaluate the correctness of the cache simulator you write in Part A. The trace files are generated by a
Linux program called valgrind. For example, typing
linux> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l
on the command line runs the executable program “ls -l”, captures a trace of each of its memory accesses
in the order they occur, and prints them on stdout.

Valgrind memory traces have the following form:
I 0400d7d4,8
 M 0421c7f0,4
 L 04f6b868,8
 S 7ff0005c8,8

Each line denotes one or two memory accesses. The format of each line is
[space]operation address,size

The operation field denotes the type of memory access:

 “I” denotes an instruction load,
 “L” a data load,
 “S” a data store,
 “M” a data modify (i.e., a data load followed by a data store).

There is never a space before each “I”.
There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit
hexadecimal memory address. The size field specifies the number of bytes accessed by the operation.

*/

/* Read in command line arguments with getopt()
 *
 * `getopt()` to handle two program options: -n, with no associated value; and
 *   n, with no associated value.
 *   t:, which expects an associated value.
 *
 * `atoi()` is a function in C that converts a string into an integer
 *   numerical representation.
 */


/* Usage Info */
void csim_help_info()
{
    printf("Usage: ./csim [-hv] -s <num> -E <num> -b <num> -t <tracefile>\n");
    printf("Options:\n");
    printf("  -h              Print this help message.\n");
    printf("  -v              Optional verbose flag.\n");
    printf("  -s <num>        Number of set index bits.\n");
    printf("  -E <num>        Number of lines per set.\n");
    printf("  -b <num>        Number of block offset bits.\n");
    printf("  -t <tracefile>  Trace file.\n");
    printf("\nExamples:\n");
    printf("  linux>  ./csim -s 4 -E 1 -b 4 -t traces/yi.trace\n");
    printf("  linux>  ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace\n");
}

/* Missing arguments error. */
void missing_args_error(char* program_name)
{
    printf("%s: Missing required command line argument\n", program_name);
}

/* Missing input file error. */
void missing_file_error(char *file)
{
    printf("%s: No such file or directory\n", file);
}


/**
 * https://leetcode.com/problems/lru-cache/description/
 * Your LRUCache struct will be instantiated and called as such:
 * LRUCache* obj = lRUCacheCreate(capacity);
 * int param_1 = lRUCacheGet(obj, key);

 * lRUCachePut(obj, key, value);

 * lRUCacheFree(obj);
*/



/**
 * the fields of the LEUCache struct:
 * memories(linked_list):
 *
 * implement the methods:
 * create(capacity)
 * get(LRUCache * cache, unsigned int address): return memory blocks
 * update(LRUCache * cache,unsigned int address):
 * free()
 *
 * @param: char * blocks;    // Pointer to a dynamically allocated char array (string)
 * Memory for the blocks field is allocated dynamically using malloc(): 
 *    blocks = (char *)malloc(b * sizeof(char)); // Allocating memory to blocks
 * Free the dynamically allocated memory:  
 *    free(line_code.blocks);
 */

typedef struct LineNode
{
    unsigned int tag;
    unsigned int valid;
    char *blocks;          // Pointer to a dynamically allocated char array (string)
    struct LineNode *prev; // Pointer to previous node
    struct LineNode *next; // Pointer to next node
} LineNode;


typedef struct CacheSet
{
    unsigned int E;
    struct LineNode *head;
    struct LineNode *tail;
} CacheSet;


typedef struct LRUCache
{
    unsigned s;
    unsigned E;
    unsigned b;
    unsigned tag_offset; //s+b
    MemAddrSize S;
    MemAddrSize B;
    MemAddrSize tag_mask;
    MemAddrSize set_mask;
    MemAddrSize block_mask; // to get the block binary value
    MemAddrSize address_mask; // to get the address binary value to copy from memory to cache
    CacheSet * sets; // sets is a array of set, and set consists of E lines, lines is build by lined list
} LRUCache;


/*
LRUCache((unsigned s, unsigned E, unsigned b) Initialize the LRU cache with s,E,b

capacity = C= S*E*B bytes
*/
LRUCache *lRUCacheCreate(unsigned s, unsigned E, unsigned b)
{
    
    unsigned tag_offset = s + b;
    unsigned  t = MEMORY_SIZE -s-b;

    // create tag_mask and set_mask by s,E,b,t
    MemAddrSize mask = 0xFFFFFFFFFFFFFFFF;
    MemAddrSize tag_mask = mask >> (s + b);
    MemAddrSize set_mask = (mask << t) >> (b + t);
    MemAddrSize block_mask= (mask<<(s+t) ) >>(s+t);
    MemAddrSize address_mask= (mask>> b ) <<b;

    MemAddrSize S = 0x1 << s;
    MemAddrSize B = 0x1 << b;

    // initialize the sets for cache, Allocating memory to sets
    CacheSet *sets = (CacheSet *)malloc(S * sizeof(CacheSet));

    // Dynamically allocate memory for the struct on the heap
    LRUCache *cache = (LRUCache *)malloc(sizeof(LRUCache));
    
    // LRUCache cache = {s, E, b, tag_offset, S, B,  tag_mask, set_mask, address_mask, sets};
    cache->s = s;
    cache->E = E;
    cache->b = b;
    cache->tag_offset = tag_offset;
    cache->S = S;
    cache->B = B;
    cache->tag_mask = tag_mask;
    cache->set_mask = set_mask;
    cache->block_mask = block_mask;
    cache->address_mask = address_mask;
    cache->sets = sets;

    // initialize the sets for cache
    for (unsigned i = 0; i < S; i++)
    {
        CacheSet *set = &cache->sets[i];
        set->E = E;
        set->head = NULL;
        set->tail = NULL;
    }
    return cache;
}

/**
 * int get(unsigned int address) Return the value of the address if the address exists (hit), otherwise return -1 (miss)
 * 1. matched by set + tag
 * 2. if hit, then get the data blocks
 * 3. if miss then put the cache: evict the data blocks and update
 * The functions get and put must each run in O(1) average time complexity.
 *
 * The operation field denotes the type of memory access:
 *  “I” denotes an instruction load,
 *  “L” a data load,
 *  “S” a data store,
 *  “M” a data modify (i.e., a data load followed by a data store).

 *
*/
int lRUCacheGet(LRUCache *cache, char operation, MemAddrSize address, unsigned size)
{
    // how to matched by set + tag?
    unsigned target_set_index = address >> cache->b & cache->set_mask;
    unsigned target_tag_index = address >> (cache->tag_offset) & cache->tag_mask;


    // find the target set
    CacheSet target_set = cache->sets[target_set_index];

    // if find the target tag and is valid, which is hit
    int hit=0;

    // find the target tag/line by for loops
    LineNode* hit_line;

    unsigned i;
    LineNode* current_line = target_set.head; 
    for(i=0; i < cache->E; i++){
        if(current_line==NULL )
        {
            break;
        }
        else if( current_line->valid && current_line->tag == target_tag_index){
            hit_line = current_line;
            hit = 1;
            // move the hit_line to the head of the cache
            if(hit_line!= target_set.head){
                LineNode* temp = hit_line->prev; // Use '->' to access the members of the struct via pointer
                temp->next = hit_line->next; 
                if(hit_line->next!= NULL){
                    hit_line->next->prev = temp;
                }
                hit_line->next = target_set.head;
                target_set.head->prev = hit_line;
                hit_line->prev = NULL;
                target_set.head = hit_line;
            }

            // if hit a line, how to get the data blocks?
            // bytes = hit_line.blocks [offset:offset + size];
            break;
        }else{
        // update the current line by linked list
        current_line = current_line->next;
        }
    }


    if(!hit)
    {
        // if miss , when and how to evict the data blocks and update?

        // add a new line node
        LineNode* new_line = (LineNode*)malloc(sizeof(LineNode));
        new_line->tag = target_tag_index;
        new_line->valid = 1;
        
        // move the local memory to block in this cache set line
        //To copy B bytes from a specific memory address into a dynamically allocated char array (blocks), you can use the memcpy function from the C standard library. Here's how to do it step by step:
        // Steps:
        // Allocate memory for the blocks array using malloc.
        // Use memcpy to copy B bytes from the source address to the dynamically allocated memory (blocks).
        // each block is a byte, blocks= B=2^b bytes
        new_line->blocks = (char*)malloc(cache->B * sizeof(char)); // Allocate memory to blocks

        MemAddrSize memory_addr = address &(cache->address_mask);
        // Cast the 64-bit integer to a pointer to a char (or another data type you need)
        char *pmemory_addr = (char*)memory_addr;  // Explicitly cast the 64-bit integer to a pointer
        // TODO:access= 16=1 0000 = memory_addr  can not access the memory address at adress 0x10
        memcpy(new_line->blocks, pmemory_addr,cache->B);
        
        //when i reach the end, evict an existing line node
        //will replace the line that was last accessed the furthest in the past. 
        if(i==(cache->E-1))
        {
            // set th tail of set
            LineNode* evicted_line = target_set.tail;
           
            if(evicted_line->prev!= NULL){
                evicted_line->prev->next = NULL;   // set the previous line node
            }
            
            target_set.tail = evicted_line->prev; // set the tail to the previous line node

            free(evicted_line->blocks);           // free the memory allocated for blocks
            free(evicted_line);                   // free the memory allocated for line node

            // set the head of the set
            new_line->prev = NULL;                 //set the prev, next to new line
            new_line->next = target_set.head;
            if(target_set.head!= NULL){
                target_set.head-> prev = new_line;
            }
            
            target_set.head = new_line;           // add the new line node to the head of the cach
            hit=-1;                               // use hit==-1 to represent the eviction

        }else{
            // add a new line node at current_line
            new_line->prev = current_line->prev;
            new_line->next = NULL; //
            if(current_line->prev!= NULL){
                current_line->prev->next = new_line;
            }
            current_line=new_line;                // assign new_line to current_line directly?
        }
    }
    // TODO: return the bytes in cache?
    return hit;
}

/*
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.
If the number of keys exceeds the capacity from this operation, evict the least recently used key.

*/
// void lRUCachePut(LRUCache *obj, int key, int value)
// {
// }

void lRUCacheFree(LRUCache *cache)
{
    free(cache->sets);
    free(cache);
}


void run_cache_simulator(CacheParams cache_params){
    
    // initialize hits, misses, evictions
    int hits = 0;
    int misses = 0;
    int evictions = 0;

    char operation;
    MemAddrSize address;
    unsigned size;

    // initialize LRU cache
    LRUCache *pcache = lRUCacheCreate(cache_params.s, cache_params.E, cache_params.b);

    // initialize the line_code
    // LineCode line_code;
    // line_code.blocks = (char *)malloc(cache_params.B * sizeof(char));

    // open the trace file
    FILE *ptrace_file = fopen(cache_params.trace_file, "r");
    if(ptrace_file == NULL){
        missing_file_error(cache_params.trace_file);
        exit(EXIT_FAILURE);
    }

    // Reading lines like " M 20,1" or "L 19,3"
    while(fscanf(ptrace_file," %c %llx,%d", &operation, &address, &size) > 0){
        // call the lRUCacheGet function to update the cache
        int result = lRUCacheGet(pcache, operation, address, size);
        if(result == -1){          
            misses++;

        }
        else{
            hits++;
        }
    }

    // close the trace file
    fclose(ptrace_file);

    // free cache
    lRUCacheFree(pcache);

    // print the summary
    printSummary(hits, misses, evictions);

}


CacheParams parseOptions(int argc, char **argv)
{   
    CacheParams cache_params;
    // Declare variables
    char *program_name = NULL;
    int opt;
    int help_flag = 0,  s_flag = 0, E_flag = 0, b_flag = 0, t_flag = 0;
    program_name = argv[0];
    // getopt loop, "a:b:c" means option 'a' takes an argument, 'b' takes an argument, 'c' has no argument
    while ((opt = getopt(argc, argv, "hvs:E:b:t:"))!=-1){
        switch (opt){  
        case 'h': // Optional help flag that prints usage info
            help_flag = 1;
            break;
        // case 'v': // Optional verbose flag that displays trace info
        //     verbose_flag = 1;
        //     break;
        
        case 's': // Number of set index bits (S = 2^s is the number of sets)
            s_flag = 1;
            cache_params.s = atoi(optarg);
            break;
        case 'E':  // Associativity (number of lines per set)
            E_flag = 1;
            cache_params.E = atoi(optarg);
            break;
        case 'b': // Number of block bits (B = 2^b is the block size)
            b_flag = 1;
            cache_params.b = atoi(optarg);
            break;
        // Name of the valgrind trace to replay
        case 't':
            t_flag = 1;
            cache_params.trace_file = optarg;
            break;
        // No command line arguments, print usage info and exit
        default:
            csim_help_info();
            // return cache_params;
        }
    }

    /* If you set `-h` argument, program will print usage info, then terminate.
     * It dooe not care the remaining arguments right or false.
     */
    if (help_flag == 1)
    {
        csim_help_info();
        exit(EXIT_SUCCESS);
    }

    // exit(0) indicates successful program termination & it is fully portable, While
    // exit(1) (usually) indicates unsucessful termination. However, it's usage is non-portable.

    /* If user missed anyone of these arguments, program will print Usage Info and
     * exit the program.
     */
    if (s_flag == 0 || E_flag == 0 || b_flag == 0 || t_flag == 0)
    {
        missing_args_error(program_name);
        csim_help_info();
        exit(EXIT_FAILURE);
    }
    return cache_params;
}




int main(int argc, char **argv)
{
    // step1: parse option
    CacheParams cache_params  = parseOptions(argc, argv);

    // step2: read all of the lines and analyze it
    run_cache_simulator(cache_params);


    return 0;
}
